#include<stdio.h>
#include<stdlib.h>


#include"Des.h" //Header file for including the permutation and S-BOXs tables


char K[16][6];  //matrix for storing the 16 round key


FILE *ptr, *ctr; //pointer for pointing the message file and ciphertex file respectively


void f(char *r, char *answer, char *key)
{
	//DES F fuction
	char expansion[8]={0}, b=0, c=0, key_1[8]={0}, row=0, col=0, answer1[4]={0};
	int i, j=0, bit, byte, k;
	
	
	//Implementation of the expansion box starts here
	for(i=0;i<4;i++)
	{
		b=(r[i] & 0X0f)<<1;
		c=(r[i] & 0Xf0)<<1;
		expansion[j++]+=c;
		expansion[j++]+=b;
		b=c=0;
	} 
	for(i=0;i<8;i++)
	{
		b=((4*i-1)+32)%32;
		byte=b/8;
		bit=b%8;
		expansion[i]=expansion[i] | ((r[byte]>>(7-bit))<<5);
		
		
		b=(4*i+1)%32;
		byte=b/8;
		bit=b%8;
		expansion[i]=expansion[i] | (r[byte]>>(7-bit));
	}
	
	
	//expanding the 48 bit key in a 64 bit array to making it similar with the output of the expansion box
	byte=7;
	bit=7;
	for(i=5;i>=0;i--)
	{
		k=8;
		while(k--)
		{
			b=key[i] & 1;
			key[i] >>= 1;
			key_1[byte] |= (b<<(7-bit));
			bit--;
			if(bit<2){
				byte--;
				bit=7;
			}	
		}
	}
	
	 
	for(i=0;i<8;i++) expansion[i] ^= key_1[i];  //XOR ing the key and the output of the expansion box
	
	
	//S-BOX implementation starts here.
	byte=0;
	for(i=0;i<8;i++)
	{
		col=(expansion[i] & 0X1e)>>1;
		row=expansion[i]&1;
		expansion[i] >>= 5;
		row |=(expansion[i]&1)<<1; 
		if(i==0){
			answer[byte] |= (S1[row*16+col])<<4;
		}
		else if(i==1){
			answer[byte++] |= S2[row*16+col];
		}
		else if(i==2){
			answer[byte] |= (S3[row*16+col])<<4;
		}
		else if(i==3){
			answer[byte++] |= S4[row*16+col];
		}
		else if(i==4){
			answer[byte] |= (S5[row*16+col])<<4;
		}
		else if(i==5){
			answer[byte++] |= S6[row*16+col];
		}
		else if(i==6){
			answer[byte] |= (S7[row*16+col])<<4;
		}
		else if(i==7){
			answer[byte++] |= S8[row*16+col];
		} 
	}
	
	
	//Applying permutation to the output of the S-BOXs
	for(i=0;i<4;i++)
	{
		k=7;
		while(k--)
		{
			int x = right_sub_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((answer[i]>>k)&1)<<(7-x%8);
			answer1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<4;i++) answer[i]=answer1[i]; 
} 


void Feistal(char *m, int round)
{
	//Function for implementing the Feistal round.
	int i, j;
	char answer[4]={0}, temp[4];
	
	
	for(i=0;i<4;i++) temp[i]=m[4+i];
	
	
	f(&m[4], answer, &K[round][0]); //Caliing the DES F function
	
	
	for(i=0;i<4;i++) m[4+i]=answer[i]^m[i];
	
	
	for(i=0;i<4;i++) m[i]=temp[i];
}


void Des_Enc(char *m)
{
	//Function for DES encryption
	int i, j, k;
	char m1[8]={0},b=0;
	
	
	//Applying initial permutation to DES input.
	for(i=0;i<8;i++)
	{
		k=8;
		while(k--)
		{
			int x = initial_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((m[i]>>k)&1)<<(7-x%8);
			m1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<8;i++)
	{
		m[i]=m1[i];
	}
	
	
	//calling the round function
	for(i=0;i<16;i++)
	{
		Feistal(m, i);
	}
	
	
	for(i=0; i<8; i++) m1[i] = 0;
	
	
	//Applying final permuration to the output the DES rounds
	for(i=0;i<8;i++)
	{
		k=8;
		while(k--)
		{
			int x = final_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((m[i]>>k)&1)<<(7-x%8);
			m1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<8;i++)
	{
		m[i]=m1[i];
	}
	
	
	for(i=0;i<8;i++) fprintf(ctr, "%c", m[i]);  //Printing the output of the DES in the ciphertext file.
}	


int main()
{
	int i, j, stop=0; 
	char m[8], iv[8], ch;  //m holds the input of the underling DES

        ptr=fopen("message.txt", "r");  //Used to point the plaintext file.
        ctr=fopen("ciphertext.txt", "w");  //Used to point the ciphertext file.
	
	for(i=0;i<8;i++) iv[i]=rand()%256;  //Generating the random IV.
	
	
	for(i=0;i<8;i++) fprintf(ctr, "%c", iv[i]); //Printing the IV in the ciphertext.txt file which is 1st block of the ciphertext in CBC mode. 
	
	
	//CBC mode of encryption starts here.
	while(1)
	{
		
		//Taking the round key in a matrix form from the file previously generated by key generation algorithm.
		FILE *ktr;   
		ktr=fopen("DesRoundKey.txt", "r");
		for(i=0;i<16;i++)
		{

			for(j=0;j<6;j++)
			{
				fscanf(ktr, "%c", &K[i][j]);
			}
		}
		fclose(ktr);
		
		
		//Taking the next 8 byte block of data from the message file which I will pass through the DES, working as the underling PRF in my CBC mode of encryption method. 
		for(i=0; i<8; i++) 
		{
			ch = fgetc(ptr);
			if(ch == EOF)
			{ stop = 1; break; }
			m[i] = ch;
		}
		if(stop) break;
		

		for(i=0; i<8; i++) m[i] ^= iv[i];
		
		Des_Enc(m); //calling DES
		
		for(i=0; i<8; i++) iv[i]=m[i];
	}		
}	
