#include<stdio.h>
#include<stdlib.h>


#include"Des.h"  //Header file for including the permutation and S-BOXs tables


char K[16][6];  //matrix for storing the 16 round key


FILE *ptr, *ctr;  //pointer for pointing the message file and ciphertex file respectively


void f(char *r, char *answer, char *key)
{
	//DES F fuction
	char expansion[8]={0}, b=0, c=0, key_1[8]={0}, row=0, col=0, answer1[4]={0};
	int i, j=0, bit, byte, k;
	
	
	//Implementation of the expansion box starts here
	for(i=0;i<4;i++)
	{
		b=(r[i] & 0X0f)<<1;
		c=(r[i] & 0Xf0)<<1;
		expansion[j++]+=c;
		expansion[j++]+=b;
		b=c=0;
	} 
	for(i=0;i<8;i++)
	{
		b=((4*i-1)+32)%32;
		byte=b/8;
		bit=b%8;
		expansion[i]=expansion[i] | ((r[byte]>>(7-bit))<<5);
		
		
		b=(4*i+1)%32;
		byte=b/8;
		bit=b%8;
		expansion[i]=expansion[i] | (r[byte]>>(7-bit));
	}
	
	
	//expanding the 48 bit key in a 64 bit array to making it similar with the output of the expansion box
	byte=7;
	bit=7;
	for(i=5;i>=0;i--)
	{
		k=8;
		while(k--)
		{
			b=key[i] & 1;
			key[i] >>= 1;
			key_1[byte] |= (b<<(7-bit));
			bit--;
			if(bit<2){
				byte--;
				bit=7;
			}	
		}
	}
	
	 
	for(i=0;i<8;i++) expansion[i] ^= key_1[i];  //XOR ing the key and the output of the expansion box
	
	
	//S-BOX implementation starts here.
	byte=0;
	for(i=0;i<8;i++)
	{
		col=(expansion[i] & 0X1e)>>1;
		row=expansion[i]&1;
		expansion[i] >>= 5;
		row |=(expansion[i]&1)<<1; 
		if(i==0){
			answer[byte] |= (S1[row*16+col])<<4;
		}
		else if(i==1){
			answer[byte++] |= S2[row*16+col];
		}
		else if(i==2){
			answer[byte] |= (S3[row*16+col])<<4;
		}
		else if(i==3){
			answer[byte++] |= S4[row*16+col];
		}
		else if(i==4){
			answer[byte] |= (S5[row*16+col])<<4;
		}
		else if(i==5){
			answer[byte++] |= S6[row*16+col];
		}
		else if(i==6){
			answer[byte] |= (S7[row*16+col])<<4;
		}
		else if(i==7){
			answer[byte++] |= S8[row*16+col];
		} 
	}
	
	
	//Applying permutation to the output of the S-BOXs
	for(i=0;i<4;i++)
	{
		k=7;
		while(k--)
		{
			int x = right_sub_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((answer[i]>>k)&1)<<(7-x%8);
			answer1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<4;i++) answer[i]=answer1[i]; 
}


void Feistal(char *c, int round)
{
	//Function for implementing the Feistal round.
	int i;
	char answer[4]={0}, temp[4];
	
	
	for(i=0;i<4;i++) temp[i]=c[i];
	
	
	f(&c[0], answer, &K[15-round][0]);  //Caliing the DES F function
	
	
	for(i=0;i<4;i++) c[i]=answer[i]^c[4+i];
	
	
	for(i=0;i<4;i++) c[4+i]=temp[i];
}


void Des_Dec(char *c)
{
	//Function for DES decryption
	int i, j, k;
	char c1[8]={0},b=0;
	
	
	//Applying initial permutation to inverse DES input.
	for(i=0;i<8;i++)
	{
		k=8;
		while(k--)
		{
			int x = initial_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((c[i]>>k)&1)<<(7-x%8);
			c1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<8;i++)
	{
		c[i]=c1[i];
	}
	
	
	//calling the round function
	for(i=0;i<16;i++)
	{
		Feistal(c, i);
	}
	
	
	for(i=0; i<8; i++) c1[i] = 0;

	
	//Applying final permuration to the output the inverse DES rounds
	for(i=0;i<8;i++)
	{
		k=8;
		while(k--)
		{
			int x = final_message_permutation[8*i + (7-k)] - 1;
			j=x/8;
			b=((c[i]>>k)&1)<<(7-x%8);
			c1[j]+=b;
			b=0;
		}
	}
	for(i=0;i<8;i++)
	{
		c[i]=c1[i];
	}
}


int main()
{
	int i, j;
	char c[8], m[8], iv[8], ch;  //c holds the input of the underling DES
	int stop = 0;
	
	
        ptr=fopen("message1.txt", "w");  //Used to point the plaintext file.  
        ctr=fopen("ciphertext.txt", "r");  //Used to point the ciphertext file.
        
        
        for(i=0; i<8; i++) fscanf(ctr, "%c", &iv[i]);  //taking the 1st block of ciphertext(64 bit data) file in IV following the convention of CBC mode
        
        
        //CBC mode of decryption starts here.
        while(1)
        {
        	//Taking the round key in a matrix form from the file previously generated by key generation algorithm.	
        	FILE *ktr;   
		ktr=fopen("DesRoundKey.txt", "r");
		for(i=0;i<16;i++)
		{
	
			for(j=0;j<6;j++)
			{
				fscanf(ktr, "%c", &K[i][j]);
			}
		}
		fclose(ktr);
		
		
		//Taking the next 8 byte block of data from the ciphertext file which I will pass through the  inverse DES, working as the underling PRF in my CBC mode of decryption method.
        	for(i=0; i<8; i++)
        	{
        	 	ch = fgetc(ctr);
			if(ch == EOF)
			{ stop = 1; break; }
			c[i] = ch;
        	}
        	if(stop) break;
        	
        	
        	char old_iv[8];
      		for(i=0; i<8; i++) old_iv[i]=iv[i];
        	for(i=0; i<8; i++) iv[i]=c[i];
        	
        	
        	Des_Dec(c);  //Calling inverse DES
        	
        	
        	for(i=0; i<8; i++) m[i] =c[i]^old_iv[i];
        	
        	
        	for(i=0; i<8; i++) fprintf(ptr, "%c", m[i]);  //Printing the result of the decryption of the ciphertext block outputed by the individual calling of inverse DES
          }
}





	
